Routing overview, mid-July

This is a proposal to add global static routing to ns-3

The previously announced roadmap:
* July 15: Support IPv4 static routing with PointToPoint numbered links
* August 15: Extend IPv4 static routing to Ethernet (shared links), add static multicast forwarding over Ethernet and PointToPoint
* Sept 15: Add static multicast forwarding over wireless interface 

This would provide the first bullet above.

Note:  This is orthogonal to Gustavo's OLSR code, but could also exist
as a static routing protocol in the framework that he proposes; right now,
this just writes directly into the existing Ipv4 routing API 

1.  Code:

- source code is in a routing module src/routing/
- an example script is in examples/simple-static-routing.cc
- StaticRouteManager is added in the run-tests unit tests

2.  Approach

Static routing is used to automatically populate the forwarding tables
in a topology without running a dynamic routing protocol or asking
the user to manually enter routes themselves.  

A single object (StaticRouteManager) is responsible for populating
the static routes on each node, using the public Ipv4 API of that node.
It queries each node in the topology for a "staticRouter" interface.
If found, it uses the API of that interface to obtain a "link state
advertisement (LSA)" for the router.  Link State Advertisements
are used in OSPF routing, and we follow their formatting.  

The StaticRouteManager populates a link state database with LSAs
gathered from the entire topology.  Then, for each router in the topology,
the StaticRouteManager executes the OSPF shortest path first (SPF) 
computation on the database, and populates the routing tables on each
node.

This computation is initiated during the pre-simulation phase (after
topology and IP addressing has been done) with the following lines of code, 
presently:
      Ptr<StaticRouteManager> routeManager = Create<StaticRouteManager> ();
      routeManager->BuildStaticRoutingDatabase ();
      routeManager->InitializeRoutes ();

The quagga (http://www.quagga.net) OSPF implementation was used as the
basis for the routing computation logic.
One benefit of following an existing OSPF SPF implementation is that
OSPF already has defined link state advertisements for all common
types of network links:
- point-to-point (serial links)
- point-to-multipoint (Frame Relay, ad hoc wireless)
- non-broadcast multiple access (ATM)
- broadcast (Ethernet)
Therefore, we think that enabling these other link types will be more
straightforward now that the underlying OSPF SPF framework is in place.

Presently, we can handle IPv4 point-to-point, numbered links, and we do
not do equal-cost multipath.

3.  Bootstrapping

Static routing can be enabled using a DoStaticRouting flag in the
default value system:
  Bind ("DoStaticRouting", "true");
This bind tells the system to use global static routing.  It results in
a StaticRouter interface being aggregated to the internet nodes and the
creation of a Route Manager component to oversee the route generation.

If this flag is true, when an InternetNode is created, it will aggregate
a routing interface to it.
  if (RoutingEnvironment::StaticRoutingEnabled())
    {
      Ptr<StaticRouter> staticRouter = Create<StaticRouter> (this);
      Object::AddInterface (staticRouter);
    }
this flag is also tested before creating a StaticRouteManager object.

4.  Some open issues

- how transparent vs. explicit the enabling of static routing should be
(e.g., if we have a higher layer Inversion-of-Control framework, do these
static routing functions exist in some kind of Init() or Presimulate() 
method?)
- whether to add some kind of flag in an InternetNode that is equivalent
to /proc/sys/net/ipv4/ip_forward , so that every InternetNode is not
necessarily a router.
- whether to continue to write to the existing IPv4 API or load a static
router component into the node like Gustavo's OLSR
- whether to make a single global forwarding table instead of distributing
it among all the routers
